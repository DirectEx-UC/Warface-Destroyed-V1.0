#include <vector>
#include <windows.h>
#include <detours.h>
#include <iostream>
#include <d3d9.h>
#include <d3dx9.h>
#include "Colors.h"
#include <time.h>
#include "Menu.h"
#pragma warning( disable: 4244 )
#pragma warning( disable: 4996 )
#pragma warning( disable: 4838 )
#pragma comment(lib, "winmm.lib")
//gh
#pragma comment(lib, "detours.lib")
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")
 
#pragma intrinsic(_ReturnAddress)
#define Player_ReturnAddress 0x6365D6 // Combat Arms
#define WFPlayer 0x84A73B
#define WarfaceSmoke 0x84E980
 
bool Esp;
bool Aimbot;
int AimKey = 2;
int AimFOV = 15;
double AimSens = 2;
double vOutY = 2.5;
DWORD frametime = timeGetTime();
 
int Espr;
int Espg;
int Espb;
 
 
int Menu;
int Menux = 25;
int Menuy = 100;
int Menuw = 190;
int Menuh = 220;
 
int bMenux = 250;
int bMenuy = 300;
int bMenuw = 200;
int bMenuh = 185;
 
int cMenux = 250;
int cMenuy = 300;
int cMenuw = 200;
int cMenuh = 120;
bool dCounter;
bool AimEsp;
bool BoneDot;
bool BoneCircle;
bool BoneCrosshair;
bool Boxes;
bool Lines;
int aMenuSelection;
int bMenuSelection;
int cMenuSelection;
 
bool EspSettings;
bool AimSettings;
double AimHeight = 0;
bool Chams;
bool Glow;
bool LTrippin;
bool Frontcolor;
bool Backcolor;
bool Trippin;
bool NoSmoke;
bool Wireframe;
int Crosshair;
bool WallHack;
#define ItemOffset 25
#define ValueOffset Menuw - 10
#define ItemOffsetB 20
#define ValueOffsetB Menuw - 10
 
LPD3DXFONT	XFont = NULL;
LPD3DXFONT	ZFont = NULL;
LPD3DXLINE	pLine = NULL;
 
LPDIRECT3DDEVICE9 pDevice;
 
typedef HRESULT(WINAPI *Prototype_Present)(LPDIRECT3DDEVICE9, CONST RECT*, CONST RECT*, HWND, CONST RGNDATA*);
typedef HRESULT(WINAPI *Prototype_Reset)(LPDIRECT3DDEVICE9, D3DPRESENT_PARAMETERS*);
typedef HRESULT(WINAPI* Prototype_DrawIndexedPrimitive)(LPDIRECT3DDEVICE9, D3DPRIMITIVETYPE, INT, UINT, UINT, UINT, UINT);
 
Prototype_Present xPresent;
Prototype_Reset xReset;
Prototype_DrawIndexedPrimitive xDrawIndexedPrimitive;
 
HRESULT WINAPI zPresent(LPDIRECT3DDEVICE9 Device, CONST RECT *pSrcRect, CONST RECT *pDestRect, HWND hDestWindow, CONST RGNDATA *pDirtyRegion);
HRESULT WINAPI zReset(LPDIRECT3DDEVICE9 Device, D3DPRESENT_PARAMETERS *pp);
HRESULT WINAPI zDrawIndexedPrimitive(LPDIRECT3DDEVICE9 Device, D3DPRIMITIVETYPE PrimType, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount);
 
bool                                XInit = false;
int                                    g_Index = -1;
HMODULE                                g_HModule = 0;
std::vector<void*>                    g_Vector;
char                                g_Text[128] = { '\0' };
void*                                g_SelectedAddress = NULL;
 
LPDIRECT3DTEXTURE9 Pink, Black, Blue, Green, Red, Orange, White, Tur, Yellow, cFront, cBack;
DWORD cColorBack[3], CurrentColorBack;
DWORD cColorFront[3], CurrentColorFront;
#define d3dColorESP D3DCOLOR_ARGB( 0, Espr, Espg, Espb )
POINT Pos;
RECT rMyRect;
#define PI 3.14159265//Defining what PI is. PI is a Circle
LPDIRECT3DDEVICE9 Device;
IDirect3DPixelShader9* pShader;
UINT pSizeOfData;
 
////////////////////////
void CaseFunction();
void bCaseFunction();
void cCaseFunction();
void DrawRect(IDirect3DDevice9* dev, int x, int y, int w, int h, D3DCOLOR color);
void Button(IDirect3DDevice9* dev, int x, int y, int w, int h, D3DCOLOR Outline);
void AddInt(int Pos, const char *text, int controller);
void AddBool(int Pos, const char *text, bool controller);
void bAddInt(int bPos, const char *text, int bcontroller);
void bAddBool(int bPos, const char *text, bool bcontroller);
void bSetIntLimits(int bcontroller, int bmax, int bmin);
void bAddIntItem(int Pos, const char *test, int controller, int max, int min);
void SetIntLimits(int bcontroller, int bmax, int bmin);
void SetIntLoop(int controller, int max, int min);
void AddIntItem(int Pos, const char *test, int controller, int max, int min);
void LBox(IDirect3DDevice9* dev, int x, int y, int w, int h, D3DCOLOR Outline);
void DrawRectangle(int x, int y, int w, int h, int r, int g, int b, int a);
void DrawFilledBox(int x, int y, int w, int h, D3DCOLOR color);
void FillRGB(int x, int y, int w, int h, D3DCOLOR color, IDirect3DDevice9* Device);
void DrawShadowText(int x, int y, D3DCOLOR color, char* String, const char * cFmt, ...);
void DrawLine(float x, float y, float x2, float y2, float width, DWORD color);
void zTitle(int x, int y, D3DCOLOR color, char* String, const char * cFmt, ...);
void Blur(float x, float y, float w, float h, D3DCOLOR ColorTwo, D3DCOLOR ColorOne, LPDIRECT3DDEVICE9 Device);
void ZLine(LPDIRECT3DDEVICE9 pDevice, int x, int y, int w, int h, D3DCOLOR Color);
void cAddIntItem(int cPos, const char *test, int ccontroller, int cmax, int cmin);
void Circle(int X, int Y, int radius, int numSides, DWORD Color);
///////////////////////////
 
void DrawShadowText(int x, int y, D3DCOLOR color, char* String, const char * cFmt, ...) // How I draw my font.
{
	RECT Font;
	Font.bottom = 0;
	Font.left = x;
	Font.top = y;
	Font.right = 0;
 
	RECT Fonts; // It's all part.
	Fonts.bottom = 0;
	Fonts.left = x + 1;
	Fonts.top = y + 1;
	Fonts.right = 0; // Shadow is pretty stuff.
 
	XFont->DrawTextA(0, String, strlen(String), &Fonts, DT_NOCLIP, 0xFF010101);
	XFont->DrawTextA(0, String, strlen(String), &Font, DT_NOCLIP, color);
}
 
void eDrawShadowText(int x, int y, D3DCOLOR color, char* String, float) // How I draw my font.
{
	RECT Font;
	Font.bottom = 0;
	Font.left = x;
	Font.top = y;
	Font.right = 0;
 
	RECT Fonts; // It's all part.
	Fonts.bottom = 0;
	Fonts.left = x + 1;
	Fonts.top = y + 1;
	Fonts.right = 0; // Shadow is pretty stuff.
 
	XFont->DrawTextA(0, String, strlen(String), &Fonts, DT_NOCLIP, 0xFF010101);
	XFont->DrawTextA(0, String, strlen(String), &Font, DT_NOCLIP, color);
}
 
void FillRGB(int x, int y, int w, int h, D3DCOLOR color, IDirect3DDevice9* Device)
{
	D3DRECT rec = { x, y, x + w, y + h };
	Device->Clear(1, &rec, D3DCLEAR_TARGET, color, 0, 0);
}
 
void zTitle(int x, int y, D3DCOLOR color, char* String, const char * cFmt, ...) // How I draw my font.
{
	RECT Font;
	Font.bottom = 0;
	Font.left = x;
	Font.top = y;
	Font.right = 0;
 
	RECT Fonts; // It's all part.
	Fonts.bottom = 0;
	Fonts.left = x + 1;
	Fonts.top = y + 1;
	Fonts.right = 0; // Shadow is pretty stuff.
 
	ZFont->DrawTextA(0, String, strlen(String), &Fonts, DT_NOCLIP, 0xFF010101);
	ZFont->DrawTextA(0, String, strlen(String), &Font, DT_NOCLIP, color);
}
 
void DrawPoint(LPDIRECT3DDEVICE9 Device, int baseX, int baseY, int baseW, int baseH, D3DCOLOR Cor)
{
	D3DRECT BarRect = { baseX, baseY, baseX + baseW, baseY + baseH };
	Device->Clear(1, &BarRect, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, Cor, 0, 0);
}
 
void DrawFilledBox(int x, int y, int w, int h, D3DCOLOR color)
{
	D3DXVECTOR2 vLine[2];
 
	XLine->SetWidth(w);
	XLine->SetAntialias(false);
	XLine->SetGLLines(true);
 
	vLine[0].x = x + w / 2;
	vLine[0].y = y;
	vLine[1].x = x + w / 2;
	vLine[1].y = y + h;
 
	XLine->Begin();
	XLine->Draw(vLine, 2, color);
	XLine->End();
}
 
void DrawLine(float x, float y, float x2, float y2, float width, DWORD color)
{
	D3DXVECTOR2 vLine[2];
	pLine->SetWidth(width);
	pLine->SetAntialias(true);
	pLine->SetGLLines(true);
	vLine[0].x = x;
	vLine[0].y = y;
	vLine[1].x = x2;
	vLine[1].y = y2;
	pLine->Begin();
	pLine->Draw(vLine, 2, color);
	pLine->End();
}
 
void SetINTCVar(const char* szString, int iVal)
{
	_asm
	{
		mov ecx, dword ptr ds : [0x175F3E8]
		mov ecx, dword ptr ds : [ecx + 0x50]
			mov edx, dword ptr ds : [ecx]
			mov eax, dword ptr ds : [edx + 0xD0]
			push szString
			call eax
			mov edx, dword ptr ds : [eax + 0x18]
			mov eax, iVal
			mov dword ptr ds : [edx], eax
	}
}
 
void PrintText(LPD3DXFONT Font, long x, long y, D3DCOLOR fontColor, char *text, ...)
{
	RECT rct;
	rct.left = x - 1;
	rct.right = x + 1;
	rct.top = y - 1;
	rct.bottom = y + 1;
 
	if (!text) { return; }
	va_list va_alist;
	char logbuf[256] = { 0 };
	va_start(va_alist, text);
	_vsnprintf(logbuf + strlen(logbuf), sizeof(logbuf) - strlen(logbuf), text, va_alist);
	va_end(va_alist);
	RECT FontRect = { x, y, x, y };
	XFont->DrawText(NULL, logbuf, -1, &rct, DT_NOCLIP, fontColor);
}
 
void DrawRect(IDirect3DDevice9* dev, int x, int y, int w, int h, D3DCOLOR color)
{
	D3DRECT BarRect = { x, y, x + w, y + h };
	dev->Clear(1, &BarRect, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, color, 0, 0);
}
 
void LBox(IDirect3DDevice9* Device, int x, int y, int w, int h, D3DCOLOR Outline)
{
	DrawRect(Device, x, y, w, 1, Outline);
	DrawRect(Device, x, y, 1, h, Outline);
	DrawRect(Device, x + w, y, 1, h, Outline);
	DrawRect(Device, x, y + h, w, 1, Outline);
}
 
void ZLine(LPDIRECT3DDEVICE9 Device, int x, int y, int w, int h, D3DCOLOR Color)
{
	struct D3DVERTEX
	{
		float x, y, z, rhw;
		D3DCOLOR color;
	};
	D3DVERTEX vertices[] =
	{
		{ x, y, 0.5f, 1.0f, Color },
		{ x + w, y + h, 0.5f, 1.0f, Color, }
	};
 
	Device->SetTexture(0, NULL);
	Device->SetPixelShader(NULL);
	Device->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
	Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
	Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	Device->SetRenderState(D3DRS_ZENABLE, FALSE);
	Device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	Device->DrawPrimitiveUP(D3DPT_LINELIST, 1, vertices, sizeof(D3DVERTEX));
}
 
void Blur(float x, float y, float w, float h, D3DCOLOR ColorTwo, D3DCOLOR ColorOne, LPDIRECT3DDEVICE9 Device)
{
	struct D3DVERTEX
	{
		float x, y, z, rhw;
		D3DCOLOR color;
	};
	D3DVERTEX   vertices[] =
	{
		{ x - 7, y, 0, 5.0f, ColorTwo },
		{ x + w + 10, y, 0, 5.0f, ColorTwo },
		{ x, y + h, 1 , 1.0f, ColorOne },
		{ x + w, y + h, 1 , 1.0f, ColorOne }
	};
 
	Device->SetTexture(0, NULL);
	Device->SetPixelShader(NULL);
	Device->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
	Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
	Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	Device->SetRenderState(D3DRS_ZENABLE, FALSE);
	Device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	Device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, vertices, sizeof(D3DVERTEX));
}
 
void DrawRectangle(int x, int y, int w, int h, int r, int g, int b, int a) {
	if (!IsBadReadPtr(pLine, sizeof(ID3DXLine))) {
		D3DXVECTOR2 vLine1[2];
		D3DXVECTOR2 vLine2[2];
		D3DXVECTOR2 vLine3[2];
		D3DXVECTOR2 vLine4[2];
 
		pLine->SetAntialias(false);
		pLine->SetGLLines(true);
 
		vLine1[0].x = x;
		vLine1[0].y = y;
		vLine1[1].x = x;
		vLine1[1].y = y + h;
 
		vLine2[0].x = x + w;
		vLine2[0].y = y;
		vLine2[1].x = x + w;
		vLine2[1].y = y + h;
 
		vLine3[0].x = x;
		vLine3[0].y = y;
		vLine3[1].x = x + w;
		vLine3[1].y = y;
 
		vLine4[0].x = x;
		vLine4[0].y = y + h;
		vLine4[1].x = x + w;
		vLine4[1].y = y + h;
 
		pLine->Begin();
		pLine->Draw(vLine1, 2, D3DCOLOR_RGBA(r, g, b, a));
		pLine->Draw(vLine2, 2, D3DCOLOR_RGBA(r, g, b, a));
		pLine->Draw(vLine3, 2, D3DCOLOR_RGBA(r, g, b, a));
		pLine->Draw(vLine4, 2, D3DCOLOR_RGBA(r, g, b, a));
		pLine->End();
	}
}
 
void cDirectClass::DrawString(ID3DXFont * XFont, int nPosX, int nPosY, D3DCOLOR dColor, const char * cFmt, ...)
{
	va_list mvalist;
	char cBuffer[256] = { 0 };
	RECT rFontRect = { nPosX, nPosY, nPosX + 16, nPosY + 120 };
 
	va_start(mvalist, cFmt);
	vsnprintf_s(cBuffer, sizeof(cBuffer), cFmt, mvalist);
	va_end(mvalist);
 
	XFont->DrawTextA(NULL, cBuffer, -1, &rFontRect, DT_LEFT | DT_NOCLIP, dColor);
}
 
struct ModelInfo_t
{
	float vOutX, vOutY;
	INT       iTeam;
	float CrosshairDistance;
};
std::vector<ModelInfo_t>ModelInfo;
 
float GetDistance(float Xx, float Yy, float xX, float yY)
{
	return sqrt((yY - Yy) * (yY - Yy) + (xX - Xx) * (xX - Xx));
}
 
 
void AddModel(LPDIRECT3DDEVICE9 Device, int iTeam)
{
	float xx, yy;
	D3DXMATRIX matrix, worldmatrix, m1;
	D3DXVECTOR4 position, input;
	D3DVIEWPORT9 dip_viewport;
	Device->GetViewport(&dip_viewport);
	Device->GetVertexShaderConstantF(36, m1, 4);
	Device->GetVertexShaderConstantF(0, worldmatrix, 3);
 
	input.x = worldmatrix._14;
	input.y = worldmatrix._24;
	input.z = worldmatrix._34 + (float)AimHeight;
 
	D3DXMatrixTranspose(&matrix, &m1);
	D3DXVec4Transform(&position, &input, &matrix);
 
	position.x = input.x * matrix._11 + input.y * matrix._21 + input.z * matrix._31 + matrix._41;
	position.y = input.x * matrix._12 + input.y * matrix._22 + input.z * matrix._32 + matrix._42;
	position.z = input.x * matrix._13 + input.y * matrix._23 + input.z * matrix._33 + matrix._43;
	position.w = input.x * matrix._14 + input.y * matrix._24 + input.z * matrix._34 + matrix._44;
 
	xx = ((position.x / position.w) * (dip_viewport.Width / 2.0f)) + dip_viewport.X + (dip_viewport.Width / 2.0f);
	yy = dip_viewport.Y + (dip_viewport.Height / 2.0f) - ((position.y / position.w) * (dip_viewport.Height / 2.0f));
 
	ModelInfo_t pModelInfo = { static_cast<float>(xx), static_cast<float>(yy), iTeam };
 
	ModelInfo.push_back(pModelInfo);
}
 
void DrawMyText(int x, int y, D3DCOLOR color, const char * cFmt, ...) // How I draw my font.
{
	CHAR buf[512] = { NULL };
	va_list ArgumentList;
	va_start(ArgumentList, cFmt);
	_vsnprintf_s(buf, sizeof(buf), sizeof(buf) - strlen(buf), cFmt, ArgumentList);
	va_end(ArgumentList);
 
	RECT Font;
	Font.bottom = 0;
	Font.left = x;
	Font.top = y;
	Font.right = 0;
 
	XFont->DrawTextA(0, buf, strlen(buf), &Font, DT_NOCLIP, color);
}
 
void Circle(int X, int Y, int radius, int numSides, DWORD Color)
{
	D3DXVECTOR2 Line[128];
	float Step = PI * 2.0 / numSides;
	int Count = 0;
	for (float a = 0; a < PI*2.0; a += Step)
	{
		float X1 = radius * cos(a) + X;
		float Y1 = radius * sin(a) + Y;
		float X2 = radius * cos(a + Step) + X;
		float Y2 = radius * sin(a + Step) + Y;
		Line[Count].x = X1;
		Line[Count].y = Y1;
		Line[Count + 1].x = X2;
		Line[Count + 1].y = Y2;
		Count += 2;
	}
	XLine->Begin();
	XLine->Draw(Line, Count, Color);
	XLine->End();
}
 
DWORD FindDevice(DWORD Len)
{
	DWORD dwObjBase = 0;
 
	dwObjBase = (DWORD)LoadLibrary("d3d9.dll");
	while (dwObjBase++ < dwObjBase + Len)
	{
		if ((*(WORD*)(dwObjBase + 0x00)) == 0x06C7
			&& (*(WORD*)(dwObjBase + 0x06)) == 0x8689
			&& (*(WORD*)(dwObjBase + 0x0C)) == 0x8689
			) {
			dwObjBase += 2; break;
		}
	}
	return(dwObjBase);
}
 
DWORD GetDeviceAddress(int VTableIndex)
{
	PDWORD VTable;
	*(DWORD*)&VTable = *(DWORD*)FindDevice(0x128000);
	return VTable[VTableIndex];
}
 
void zThread()
{
	xPresent = (Prototype_Present)DetourFunction((PBYTE)GetDeviceAddress(17),
		(PBYTE)zPresent);
	xReset = (Prototype_Reset)DetourFunction((PBYTE)GetDeviceAddress(16),
		(PBYTE)zReset);
	xDrawIndexedPrimitive = (Prototype_DrawIndexedPrimitive)DetourFunction((PBYTE)GetDeviceAddress(82),
		(PBYTE)zDrawIndexedPrimitive);
}
 
BOOL WINAPI DllMain(HINSTANCE hInsatnce, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		g_HModule = hInsatnce;
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)zThread, 0, 0, 0);
		MessageBox(0, "You Must Close this box - Injection Successful.", " Trippy Warface V3.2", 0);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		if (XFont != NULL)
		{
			XFont->OnLostDevice();
			XFont->OnResetDevice();
			XFont->Release();
			XFont = NULL;
		}
 
		DetourRemove((PBYTE)zPresent, (PBYTE)zPresent);
		DetourRemove((PBYTE)zReset, (PBYTE)zReset);
		DetourRemove((PBYTE)zDrawIndexedPrimitive, (PBYTE)zDrawIndexedPrimitive);
	}
	return TRUE;
}
 
HRESULT cGenTex(LPDIRECT3DDEVICE9 Device, IDirect3DTexture9 **ppD3Dtex, DWORD colour32)
{
	if (FAILED(Device->CreateTexture(8, 8, 1, 0, D3DFMT_A4R4G4B4, D3DPOOL_MANAGED, ppD3Dtex, NULL)))
		return E_FAIL;
 
	WORD colour16 = ((WORD)((colour32 >> 28) & 0xF) << 12)
		| (WORD)(((colour32 >> 20) & 0xF) << 8)
		| (WORD)(((colour32 >> 12) & 0xF) << 4)
		| (WORD)(((colour32 >> 4) & 0xF) << 0);
 
	D3DLOCKED_RECT d3dlr;
	(*ppD3Dtex)->LockRect(0, &d3dlr, 0, 0);
	WORD *pDst16 = (WORD*)d3dlr.pBits;
 
	for (int xy = 0; xy < 8 * 8; xy++)
		*pDst16++ = colour16;
 
	(*ppD3Dtex)->UnlockRect(0);
 
	return S_OK;
}
 
 
HRESULT WINAPI zPresent(LPDIRECT3DDEVICE9 Device, CONST RECT *pSrcRect, CONST RECT *pDestRect, HWND hDestWindow, CONST RGNDATA *pDirtyRegion)
{
	D3DVIEWPORT9 VP;
	memset(&VP, 0, sizeof(D3DVIEWPORT9));
	Device->GetViewport(&VP);
	float ScreenCenterX = (float)VP.Width / 2;
	float ScreenCenterY = (float)VP.Height / 2;
 
	LPDIRECT3DDEVICE9 pDevice;
	pDevice = Device;
 
	if (Crosshair > 0)
		if (Crosshair == 1)
		{
			D3DRECT rec1 = { ScreenCenterX - 5, ScreenCenterY, ScreenCenterX + 5, ScreenCenterY + 1 };
			D3DRECT rec2 = { ScreenCenterX, ScreenCenterY - 5, ScreenCenterX + 1,ScreenCenterY + 5 };
			Device->Clear(1, &rec1, D3DCLEAR_TARGET, D3DCOLOR_XRGB(255, 0, 0), 0, 0);
			Device->Clear(1, &rec2, D3DCLEAR_TARGET, D3DCOLOR_XRGB(255, 0, 0), 0, 0);
		}
 
	if (Crosshair > 0)
		if (Crosshair == 2)
		{
			D3DRECT rec1 = { ScreenCenterX - 5, ScreenCenterY, ScreenCenterX + 5, ScreenCenterY + 1 };
			D3DRECT rec2 = { ScreenCenterX, ScreenCenterY - 5, ScreenCenterX + 1,ScreenCenterY + 5 };
			Device->Clear(1, &rec1, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 255, 0), 0, 0);
			Device->Clear(1, &rec2, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 255, 0), 0, 0);
		}
 
	if (Crosshair > 0 && Crosshair == 3)
	{
		D3DRECT rec1 = { ScreenCenterX - 5, ScreenCenterY, ScreenCenterX + 5, ScreenCenterY + 1 };
		D3DRECT rec2 = { ScreenCenterX, ScreenCenterY - 5, ScreenCenterX + 1,ScreenCenterY + 5 };
		Device->Clear(1, &rec1, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 255), 0, 0);
		Device->Clear(1, &rec2, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 255), 0, 0);
	}
 
	if (Crosshair > 0 && Crosshair == 4)
	{
		D3DRECT rec1 = { ScreenCenterX - 5, ScreenCenterY, ScreenCenterX + 5, ScreenCenterY + 1 };
		D3DRECT rec2 = { ScreenCenterX, ScreenCenterY - 5, ScreenCenterX + 1,ScreenCenterY + 5 };
		LBox(Device, ScreenCenterX - 5, ScreenCenterY - 5, 10, 10, d3dColorWhite); // Outline vpx and y = Viewpoint. "Center"
	}
 
	if (Crosshair > 0 && Crosshair == 5)
	{
		FillRGB(ScreenCenterX - 20, ScreenCenterY, 40, 1, d3dColorBlack, Device);//Purple
		FillRGB(ScreenCenterX, ScreenCenterY - 20, 1, 40, d3dColorBlack, Device);
		FillRGB(ScreenCenterX - 17, ScreenCenterY, 34, 1, d3dColorBlue, Device);//Blue
		FillRGB(ScreenCenterX, ScreenCenterY - 17, 1, 34, d3dColorBlue, Device);
		FillRGB(ScreenCenterX - 14, ScreenCenterY, 28, 1, d3dColorWhite, Device);//Cyan
		FillRGB(ScreenCenterX, ScreenCenterY - 14, 1, 28, d3dColorWhite, Device);
		FillRGB(ScreenCenterX - 11, ScreenCenterY, 22, 1, d3dColorGreen, Device);//Green
		FillRGB(ScreenCenterX, ScreenCenterY - 11, 1, 22, d3dColorGreen, Device);
		FillRGB(ScreenCenterX - 9, ScreenCenterY, 18, 1, d3dColorYellow, Device);//Yellow
		FillRGB(ScreenCenterX, ScreenCenterY - 9, 1, 18, d3dColorYellow, Device);
		FillRGB(ScreenCenterX - 6, ScreenCenterY, 12, 1, d3dColorLightBlue, Device);//Orange
		FillRGB(ScreenCenterX, ScreenCenterY - 6, 1, 12, d3dColorLightBlue, Device);
		FillRGB(ScreenCenterX - 3, ScreenCenterY, 6, 1, d3dColorRed, Device);//Red
		FillRGB(ScreenCenterX, ScreenCenterY - 3, 1, 6, d3dColorRed, Device);
	}
 
	if (Crosshair > 0 && Crosshair == 6)
	{
		FillRGB(ScreenCenterX - 13, ScreenCenterY, 10, 1, d3dColorRed, Device);//Left line
		FillRGB(ScreenCenterX + 4, ScreenCenterY, 10, 1, d3dColorRed, Device);//Right line
		FillRGB(ScreenCenterX, ScreenCenterY - 13, 1, 10, d3dColorRed, Device);//Top line
		FillRGB(ScreenCenterX, ScreenCenterY + 4, 1, 10, d3dColorRed, Device);//Bottom line
	}
 
	if (Crosshair > 0 && Crosshair == 7)
	{
		FillRGB(ScreenCenterX - 13, ScreenCenterY, 10, 1, d3dColorBlue, Device);//Left line
		FillRGB(ScreenCenterX + 4, ScreenCenterY, 10, 1, d3dColorBlue, Device);//Right line
		FillRGB(ScreenCenterX, ScreenCenterY - 13, 1, 10, d3dColorBlue, Device);//Top line
		FillRGB(ScreenCenterX, ScreenCenterY + 4, 1, 10, d3dColorBlue, Device);//Bottom line
	}
 
	cDirectX.InitObjects(Device);
 
	if (!XInit)
	{
		if (XFont == NULL)
			D3DXCreateFont(Device, 14, 0, FW_NORMAL, 1, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "red", &XFont);
		if (ZFont == NULL)
			D3DXCreateFont(Device, 14, 0, FW_EXTRABOLD, 1, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "red", &ZFont);
		if (XLine == NULL) D3DXCreateLine(Device, &XLine);
		cColorFront[CurrentColorFront] = 255;
		cColorBack[CurrentColorBack] = 255;
		XInit = true;
	}
 
	if (Frontcolor && !Backcolor)
		if (ModelInfo.size() != NULL)
		{
			for (unsigned int i = 0; i < ModelInfo.size(); i++)
			{
				ModelInfo[i].CrosshairDistance = GetDistance(ModelInfo[i].vOutX, ModelInfo[i].vOutY, ScreenCenterX, ScreenCenterY);
				//============================================================================================
				cGenTex(Device, &cFront, D3DCOLOR_ARGB(255, cColorFront[0], cColorFront[1], cColorFront[2]));
 
				if (GetAsyncKeyState(VK_ADD) && cColorFront[CurrentColorFront] < 250)
					cColorFront[CurrentColorFront] += 10; //On pressing "+" Slider will increase value on current color
				if (GetAsyncKeyState(VK_SUBTRACT) && cColorFront[CurrentColorFront] > 5)
					cColorFront[CurrentColorFront] -= 10; //On pressing "-" Slider will decrease value on current color
 
				if (GetAsyncKeyState(0x31) & 1) //On pressing "1" only the Red slider will increase/decrease
					CurrentColorFront = 0;
				else if (GetAsyncKeyState(0x32) & 1) //On pressing "2" only the Green slider will increase/decrease
					CurrentColorFront = 1;
				else if (GetAsyncKeyState(0x33) & 1) //On pressing "3" only the Blue slider will increase/decrease
					CurrentColorFront = 2;
 
				DrawShadowText(Menux + 5, Menuy + 245, d3dColorRed, "Choose Color : 1/2/3 : +/-", 0);
 
				//==========================================================================================================================================
				FillRGB((int)ModelInfo[i].vOutX + 24, (int)ModelInfo[i].vOutY - 126.5, 7, 126.5, D3DCOLOR_ARGB(255, 255, 0, 0), Device);//Red Slider Bar
				FillRGB((int)ModelInfo[i].vOutX + 25, (int)ModelInfo[i].vOutY - cColorFront[0] / 2, 10, 1, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Red Slider
																																					  //
				FillRGB((int)ModelInfo[i].vOutX + 40, (int)ModelInfo[i].vOutY - 126.5, 7, 126.5, D3DCOLOR_ARGB(255, 0, 255, 0), Device);//Green Slider Bar
				FillRGB((int)ModelInfo[i].vOutX + 40, (int)ModelInfo[i].vOutY - cColorFront[1] / 2, 10, 1, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Green Slider
																																					  //
				FillRGB((int)ModelInfo[i].vOutX + 55, (int)ModelInfo[i].vOutY - 126.5, 7, 126.5, D3DCOLOR_ARGB(255, 0, 0, 255), Device);//Blue Slider Bar
				FillRGB((int)ModelInfo[i].vOutX + 55, (int)ModelInfo[i].vOutY - cColorFront[2] / 2, 10, 1, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Blue Slider
				//==========================================================================================================================================
			}
		}
			//============================================================================================
	if (Backcolor && !Frontcolor)
		if (ModelInfo.size() != NULL)
			{
				for (unsigned int i = 0; i < ModelInfo.size(); i++)
				{
					ModelInfo[i].CrosshairDistance = GetDistance(ModelInfo[i].vOutX, ModelInfo[i].vOutY, ScreenCenterX, ScreenCenterY);
					//============================================================================================
					cGenTex(Device, &cBack, D3DCOLOR_ARGB(255, cColorBack[0], cColorBack[1], cColorBack[2]));
 
					if (GetAsyncKeyState(VK_ADD) && cColorBack[CurrentColorBack] < 250)
						cColorBack[CurrentColorBack] += 10; //On pressing "+" Slider will increase value on current color
					if (GetAsyncKeyState(VK_SUBTRACT) && cColorBack[CurrentColorBack] > 5)
						cColorBack[CurrentColorBack] -= 10; //On pressing "-" Slider will decrease value on current color
 
					if (GetAsyncKeyState(0x31) & 1) //On pressing "1" only the Red slider will increase/decrease
						CurrentColorBack = 0;
					else if (GetAsyncKeyState(0x32) & 1) //On pressing "2" only the Green slider will increase/decrease
						CurrentColorBack = 1;
					else if (GetAsyncKeyState(0x33) & 1) //On pressing "3" only the Blue slider will increase/decrease
						CurrentColorBack = 2;
 
					DrawShadowText(Menux + 5, Menuy + 245, d3dColorRed, "Choose Color : 1/2/3 : +/-", 0);
 
					//==========================================================================================================================================
					FillRGB((int)ModelInfo[i].vOutX + 24, (int)ModelInfo[i].vOutY - 126.5, 7, 126.5, D3DCOLOR_ARGB(255, 255, 0, 0), Device);//Red Slider Bar
					FillRGB((int)ModelInfo[i].vOutX + 25, (int)ModelInfo[i].vOutY - cColorBack[0] / 2, 10, 1, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Red Slider
																																						  //
					FillRGB((int)ModelInfo[i].vOutX + 40, (int)ModelInfo[i].vOutY - 126.5, 7, 126.5, D3DCOLOR_ARGB(255, 0, 255, 0), Device);//Green Slider Bar
					FillRGB((int)ModelInfo[i].vOutX + 40, (int)ModelInfo[i].vOutY - cColorBack[1] / 2, 10, 1, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Green Slider
																																						  //
					FillRGB((int)ModelInfo[i].vOutX + 55, (int)ModelInfo[i].vOutY - 126.5, 7, 126.5, D3DCOLOR_ARGB(255, 0, 0, 255), Device);//Blue Slider Bar
					FillRGB((int)ModelInfo[i].vOutX + 55, (int)ModelInfo[i].vOutY - cColorBack[2] / 2, 10, 1, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Blue Slider
					//==========================================================================================================================================
				}
				//============================================================================================
			}
 
 
	if (ModelInfo.size() != NULL)
	{
		for (unsigned int i = 0; i < ModelInfo.size(); i++)
		{
			if (Esp)
			{
				ModelInfo[i].CrosshairDistance = GetDistance(ModelInfo[i].vOutX, ModelInfo[i].vOutY, ScreenCenterX, ScreenCenterY);
 
				if (ModelInfo[i].vOutX > 1 && ModelInfo[i].vOutY > 1)
 
					Blur((int)ModelInfo[i].vOutX - 20, (int)ModelInfo[i].vOutY - 40, 35, 25, D3DCOLOR D3DCOLOR_ARGB(0, Espr, Espg, Espb), D3DCOLOR d3dColorWhite, Device);
 
					if (Boxes)
					{
						LBox(Device, (int)ModelInfo[i].vOutX - 11, (int)ModelInfo[i].vOutY - 11, 20, 30, D3DCOLOR_ARGB(0, Espr, Espg, Espb)); // Selection
					}
 
				if (AimEsp && (GetAsyncKeyState(VK_LBUTTON) || (GetAsyncKeyState(VK_RBUTTON) & 0x8000)))
					DrawShadowText((int)ModelInfo[i].vOutX - 10, (int)ModelInfo[i].vOutY + 35, d3dColorGreen, "Aim-Assist: Active", 0);
				else if (AimEsp)
					DrawShadowText((int)ModelInfo[i].vOutX - 10, (int)ModelInfo[i].vOutY + 35, d3dColorWhite, "Aim-Assist: Pending", 0);
 
				if (AimEsp && (GetAsyncKeyState(VK_LBUTTON)))
				{
					zTitle((int)ModelInfo[i].vOutX - 10, (int)ModelInfo[i].vOutY + 45, d3dColorRed, "FIRE!!", 0);
				}
 
				if (BoneCircle)
				{
					DrawMyText((int)ModelInfo[i].vOutX - 2, (int)ModelInfo[i].vOutY - 8, d3dColorWhite, "o", 0);
				}
 
				if (BoneDot)
				{
					zTitle((int)ModelInfo[i].vOutX - 1, (int)ModelInfo[i].vOutY - 10, d3dColorWhite, ".", 0);
				}
 
				if (Lines)
				{
						ZLine(Device, (int)ModelInfo[i].vOutX, (int)ModelInfo[i].vOutY + 10, ScreenCenterX / 2, ScreenCenterY / 2, d3dColorWhite);
				}
 
				if (BoneCrosshair)
				{
					FillRGB((int)ModelInfo[i].vOutX - 13, (int)ModelInfo[i].vOutY, 10, 1, D3DCOLOR_ARGB(0, Espr, Espg, Espb), Device);//Left line
					FillRGB((int)ModelInfo[i].vOutX + 4, (int)ModelInfo[i].vOutY, 10, 1, D3DCOLOR_ARGB(0, Espr, Espg, Espb), Device);//Right line
					FillRGB((int)ModelInfo[i].vOutX, (int)ModelInfo[i].vOutY - 13, 1, 10, D3DCOLOR_ARGB(0, Espr, Espg, Espb), Device);//Top line
					FillRGB((int)ModelInfo[i].vOutX, (int)ModelInfo[i].vOutY + 4, 1, 10, D3DCOLOR_ARGB(0, Espr, Espg, Espb), Device);//Bottom line
				}
 
 
				if (dCounter)
				{
					if (ModelInfo[i].vOutX > 1 && ModelInfo[i].vOutY > 1)
					DrawMyText((int)ModelInfo[i].vOutX - 10, (int)ModelInfo[i].vOutY - 35, d3dColorWhite, "%.f", ModelInfo[i].CrosshairDistance / 2);
				}
			}
		}
	}
 
	if (ModelInfo.size() != NULL)
	{
			UINT BestTarget = -1;
			DOUBLE fClosestPos = 99999;
 
			for (unsigned int i = 0; i < ModelInfo.size(); i++)
				if (Aimbot)
				{
					float radiusx = AimFOV * (ScreenCenterX / 100);
					float radiusy = AimFOV * (ScreenCenterY / 100);
 
					ModelInfo[i].CrosshairDistance = GetDistance(ModelInfo[i].vOutX, ModelInfo[i].vOutY, ScreenCenterX, ScreenCenterY);
 
					if (ModelInfo[i].vOutX >= ScreenCenterX - radiusx && ModelInfo[i].vOutX <= ScreenCenterX + radiusx && ModelInfo[i].vOutY >= ScreenCenterY - radiusy && ModelInfo[i].vOutY <= ScreenCenterY + radiusy)
					{
						if (ModelInfo[i].CrosshairDistance < fClosestPos)
						{
							fClosestPos = ModelInfo[i].CrosshairDistance;
							BestTarget = i;
						}
					}
				}
 
			if (AimKey == 1 && BestTarget != -1)
		{
			double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
			double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
			DistX /= 1;
			DistY /= 1;
 
			if (Aimbot && (GetAsyncKeyState(VK_SHIFT) & 0x8000))
			{
				if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
				{
					mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
					frametime = timeGetTime();
				}
			}
		}
 
			if (AimKey == 2 && BestTarget != -1)
			{
				double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
				double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
				DistX /= 1;
				DistY /= 1;
 
				if (Aimbot && (GetAsyncKeyState(VK_RBUTTON) & 0x8000))
				{
					if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
					{
						mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
						frametime = timeGetTime();
					}
				}
			}
 
			if (AimKey == 3 && BestTarget != -1)
			{
				double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
				double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
				DistX /= 1;
				DistY /= 1;
 
				if (Aimbot && (GetAsyncKeyState(VK_LBUTTON) & 0x8000))
				{
					if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
					{
						mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
						frametime = timeGetTime();
					}
				}
			}
 
			if (AimKey == 4 && BestTarget != -1)
			{
				double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
				double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
				DistX /= 1;
				DistY /= 1;
 
				if (Aimbot && (GetAsyncKeyState(VK_CONTROL) & 0x8000))
				{
					if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
					{
						mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
						frametime = timeGetTime();
					}
				}
			}
 
			if (AimKey == 5 && BestTarget != -1)
			{
				double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
				double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
				DistX /= 1;
				DistY /= 1;
 
				if (Aimbot && (GetAsyncKeyState(VK_MENU) & 0x8000))
				{
					if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
					{
						mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
						frametime = timeGetTime();
					}
				}
			}
 
			if (AimKey == 6 && BestTarget != -1)
			{
				double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
				double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
				DistX /= 1;
				DistY /= 1;
 
				if (Aimbot && (GetAsyncKeyState(VK_SPACE) & 0x8000))
				{
					if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
					{
						mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
						frametime = timeGetTime();
					}
				}
			}
 
			if (AimKey == 7 && BestTarget != -1)
			{
				double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
				double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
				DistX /= 1;
				DistY /= 1;
 
				if (Aimbot && (GetAsyncKeyState(0x58) & 0x8000))
				{
					if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
					{
						mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
						frametime = timeGetTime();
					}
				}
			}
 
			if (AimKey == 8 && BestTarget != -1)
			{
				double DistX = ModelInfo[BestTarget].vOutX - ScreenCenterX;
				double DistY = ModelInfo[BestTarget].vOutY - ScreenCenterY;
 
				DistX /= 1;
				DistY /= 1;
 
				if (Aimbot && (GetAsyncKeyState(0x43) & 0x8000))
				{
					if (timeGetTime() >= (frametime + CLOCKS_PER_SEC / 100))
					{
						mouse_event(MOUSEEVENTF_MOVE, (int)DistX, (int)DistY, 0, NULL);
						frametime = timeGetTime();
					}
				}
			}
	}
	
 
			ModelInfo.clear();
 
	if (GetAsyncKeyState(VK_INSERT) & 1) { Menu = !Menu; }
 
	CaseFunction();
	int x = 1;
	for (int x = 0; x < 20; x++) {
		if (Menu && aMenuSelection == x) {
 
			LBox(Device, Menux, Menuy - 20, Menuw + 25, Menuh + 20, d3dColorWhite); // Outline
			DrawFilledBox(Menux, Menuy, Menuw + 25, Menuh + 20, D3DCOLOR_ARGB(0, 150, 255, 155)); //Overall Background
			DrawFilledBox(Menux, Menuy - 20, Menuw + 25, Menuh + 20, D3DCOLOR_ARGB(155, 25, 56, 100)); //Title Background
			LBox(Device, Menux, Menuy + (15 * x), Menuw + 25, 15, d3dColorWhite); // Selection
			Blur(Menux, Menuy + (15 * x), Menuw + 25, 15, D3DCOLOR D3DCOLOR_ARGB(255, 100, 0, 155), D3DCOLOR d3dColorWhite, Device);// Selection
 
			zTitle(Menux + 18, Menuy - 20, d3dColorWhite, "DirectEx", 0);
			AddBool(1, "Chams", Chams);
			AddBool(2, "Translucent Chams", Glow);
			AddBool(3, "Front Chams Color", Frontcolor);
			AddBool(4, "Back Chams Color", Backcolor);
			AddBool(5, "Auto-Aim", Aimbot);
			AddBool(6, "Esp", Esp);
			AddBool(7, "No-Smoke", NoSmoke);
			AddBool(8, "Esp-Settings", EspSettings);
			AddBool(9, "Aim-Settings", AimSettings);
			AddBool(10, "Wire-Frame", Wireframe);
			AddIntItem(11, "Cross-Hair", Crosshair, 1, 0);
			AddBool(12, "Wall-Hack", WallHack);
			AddBool(13, "Rage Quit", LTrippin);
			LBox(Device, Menux, Menuy - 20, Menuw + 25, Menuh, d3dColorWhite); // Outline
			zTitle(Menux + 20, Menuh + 80, d3dColorWhite, "Warface Destroyed UC-Forum V1.0", 0); 
			/////////////////////////////////////////////////////////////////////////////////////////////////////////
 
			if (LTrippin) {
				system("taskkill /F /T /IM Game.exe");
			}
 
			if (Frontcolor)
				if (!Backcolor && !Esp)
				{
					cGenTex(Device, &cFront, D3DCOLOR_ARGB(255, cColorFront[0], cColorFront[1], cColorFront[2]));
 
					DrawShadowText(Menux + 5, Menuy + 245, d3dColorRed, "Choose Color : 1/2/3 : +/-", 0);
 
					if (GetAsyncKeyState(VK_ADD) && cColorFront[CurrentColorFront] < 250)
						cColorFront[CurrentColorFront] += 10; //On pressing "+" Slider will increase value on current color
					if (GetAsyncKeyState(VK_SUBTRACT) && cColorFront[CurrentColorFront] > 5)
						cColorFront[CurrentColorFront] -= 10; //On pressing "-" Slider will decrease value on current color
 
					if (GetAsyncKeyState(0x31) & 1) //On pressing "1" only the Red slider will increase/decrease
						CurrentColorFront = 0;
					else if (GetAsyncKeyState(0x32) & 1) //On pressing "2" only the Green slider will increase/decrease
						CurrentColorFront = 1;
					else if (GetAsyncKeyState(0x33) & 1) //On pressing "3" only the Blue slider will increase/decrease
						CurrentColorFront = 2;
 
 
					FillRGB(325, 135 + 3, 255, 8, D3DCOLOR_ARGB(255, 255, 0, 0), Device);//Red Slider Bar
					FillRGB(325 + cColorFront[0], 136, 2, 11, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Red Slider
					FillRGB(325, 150 + 3, 255, 8, D3DCOLOR_ARGB(255, 0, 255, 0), Device);//Green Slider Bar
					FillRGB(325 + cColorFront[1], 150 + 1, 2, 11, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Green Slider
					FillRGB(325, 165 + 3, 255, 8, D3DCOLOR_ARGB(255, 0, 0, 255), Device);//Blue Slider Bar
					FillRGB(325 + cColorFront[2], 165 + 1, 2, 11, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Blue Slider
				}
 
			if (Backcolor)
				if (!Frontcolor && !Esp)
				{
					cGenTex(Device, &cBack, D3DCOLOR_ARGB(255, cColorBack[0], cColorBack[1], cColorBack[2]));
 
					FillRGB(325, 135 + 3, 255, 8, D3DCOLOR_ARGB(255, 255, 0, 0), Device);//Red Slider Bar
					FillRGB(325 + cColorBack[0], 135 + 1, 2, 11, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Red Slider
					FillRGB(325, 150 + 3, 255, 8, D3DCOLOR_ARGB(255, 0, 255, 0), Device);//Green Slider Bar
					FillRGB(325 + cColorBack[1], 150 + 1, 2, 11, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Green Slider
					FillRGB(325, 165 + 3, 255, 8, D3DCOLOR_ARGB(255, 0, 0, 255), Device);//Blue Slider Bar
					FillRGB(325 + cColorBack[2], 165 + 1, 2, 11, D3DCOLOR_ARGB(255, 255, 255, 255), Device);//Blue Slider
 
					DrawShadowText(Menux + 5, Menuy + 245, d3dColorRed, "Choose Color : 1/2/3 : +/-", 0);
 
					if (GetAsyncKeyState(VK_ADD) && cColorBack[CurrentColorBack] < 250)
						cColorBack[CurrentColorBack] += 10; //On pressing "+" Slider will increase value on current color
					if (GetAsyncKeyState(VK_SUBTRACT) && cColorBack[CurrentColorBack] > 5)
						cColorBack[CurrentColorBack]-= 10; //On pressing "-" Slider will decrease value on current color
 
					if (GetAsyncKeyState(0x31) & 1) //On pressing "1" only the Red slider will increase/decrease
						CurrentColorBack = 0;
					else if (GetAsyncKeyState(0x32) & 1) //On pressing "2" only the Green slider will increase/decrease
						CurrentColorBack = 1;
					else if (GetAsyncKeyState(0x33) & 1) //On pressing "3" only the Blue slider will increase/decrease
						CurrentColorBack = 2;
				}
		}
	}
 
	if (EspSettings)
	{
		bCaseFunction();
		int x = 1;
		for (int x = 0; x < 20; x++) {
			if (EspSettings && bMenuSelection == x) {
				LBox(Device, bMenux, bMenuy - 20, bMenuw + 25, bMenuh + 20, d3dColorWhite); // Outline
				DrawFilledBox(bMenux, bMenuy, bMenuw + 25, bMenuh + 20, D3DCOLOR_ARGB(0, 25, 255, 155)); //Overall Background
				DrawFilledBox(bMenux, bMenuy - 20, bMenuw + 25, bMenuh + 20, D3DCOLOR_ARGB(155, 25, 56, 100)); //Title Background
				LBox(Device, bMenux, bMenuy + (15 * x), bMenuw + 25, 15, d3dColorWhite); // Selection
				Blur(bMenux, bMenuy + (15 * x), bMenuw + 25, 15, D3DCOLOR D3DCOLOR_ARGB(255, 100, 0, 155), D3DCOLOR d3dColorWhite, Device);// Selection
				zTitle(bMenux + 18, bMenuy - 20, d3dColorWhite, "Esp Settings", 0);
				bAddBool(1, "Boxes", Boxes);
				bAddIntItem(2, "Esp Red", Espr, 1, 0);
				bAddIntItem(3, "Esp Green", Espg, 1, 0);
				bAddIntItem(4, "Esp Blue", Espb, 1, 0);
				bAddBool(5, "Status Esp", AimEsp);
				bAddBool(6, "Distance Counter", dCounter);
				bAddBool(7, "Bone Dot", BoneDot);
				bAddBool(8, "Bone Circle", BoneCircle);
				bAddBool(9, "Bone Crosshair", BoneCrosshair);
				bAddBool(10, "Lines", Lines);
				cAddIntItem(11, "Bone Height ( + 0.1 )", AimHeight, 1, 0);
				bAddIntItem(12, "Go Back", EspSettings, 1, 0);
			}
		}
	}
 
	if (AimSettings)
	{
		cCaseFunction();
		int x = 1;
		for (int x = 0; x < 20; x++) {
			if (AimSettings && cMenuSelection == x) {
 
				LBox(Device, cMenux, cMenuy - 20, cMenuw + 25, cMenuh + 20, d3dColorWhite); // Outline
				DrawFilledBox(cMenux, cMenuy, cMenuw + 25, cMenuh + 20, D3DCOLOR_ARGB(0, 25, 255, 155)); //Overall Background
				DrawFilledBox(cMenux, cMenuy - 20, cMenuw + 25, cMenuh + 20, D3DCOLOR_ARGB(155, 25, 56, 100)); //Title Background
				LBox(Device, cMenux, cMenuy + (15 * x), cMenuw + 25, 15, d3dColorWhite); // Selection
				Blur(cMenux, cMenuy + (15 * x), cMenuw + 25, 15, D3DCOLOR D3DCOLOR_ARGB(255, 100, 0, 155), D3DCOLOR d3dColorWhite, Device);// Selection
 
				zTitle(cMenux + 18, cMenuy - 20, d3dColorWhite, "Aim Settings", 0);
				cAddIntItem(1, "Aim Sensitivity ( + 0.5 )", AimSens, 1, 0);
				cAddIntItem(2, "Bone Height ( + 0.1 )", AimHeight, 1, 0);
				cAddIntItem(3, "Aim Key", AimKey, 1, 0);
				if (AimKey == 1) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - Shift", 0);
				else if (AimKey == 2) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - RMouse", 0);
				else if (AimKey == 3) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - LMouse", 0);
				else if (AimKey == 4) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - Ctrl", 0);
				else if (AimKey == 5) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - Alt", 0);
				else if (AimKey == 6) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - Space", 0);
				else if (AimKey == 7) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - X", 0);
				else if (AimKey == 8) DrawShadowText(cMenux + 235, cMenuy, d3dColorGreen, "AimKey - C", 0);
				cAddIntItem(4, "Go Back", AimSettings, 1, 0);
			}
		}
	}
 
	if (!Menu)
	{
		zTitle(ScreenCenterX, ScreenCenterY - 300, d3dColorWhite, "Press Insert: Open Menu", 0);
	}
 
 
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
	return xPresent(Device, pSrcRect, pDestRect, hDestWindow, pDirtyRegion);
}
 
HRESULT WINAPI zReset(LPDIRECT3DDEVICE9 Device, D3DPRESENT_PARAMETERS *pp)
{
 
	if (XFont)
	XFont->OnResetDevice();
	XFont->OnResetDevice();
	if (pLine)
	pLine->OnResetDevice();
	pLine->OnResetDevice();
 
	return xReset(Device, pp);
 
}
HRESULT WINAPI zDrawIndexedPrimitive(LPDIRECT3DDEVICE9 Device, D3DPRIMITIVETYPE PrimType, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount)
{
	IDirect3DVertexBuffer9* pStreamData = NULL;
	UINT xOffset, Stride;
	if (Device->GetStreamSource(0, &pStreamData, &xOffset, &Stride) == D3D_OK)
		pStreamData->Release();
 
	if (SUCCEEDED(Device->GetPixelShader(&pShader)))
		if (pShader != NULL)
			if (SUCCEEDED(pShader->GetFunction(NULL, &pSizeOfData)))
				if (pShader != NULL) { pShader->Release(); pShader = NULL; }
	void* ReturnAddress = _ReturnAddress();
	
	if (Chams)
	if (ReturnAddress != NULL && ReturnAddress == (void *)WFPlayer)
	{
		Device->SetTexture(0, cBack);
		Device->SetRenderState(D3DRS_ZENABLE, false);
		Device->DrawIndexedPrimitive(PrimType, BaseVertexIndex, MinVertexIndex, NumVertices, startIndex, primCount);
		Device->SetRenderState(D3DRS_ZENABLE, true);
		Device->SetTexture(0, cFront);
	}
 
	if (Glow)
		if (ReturnAddress != NULL && ReturnAddress == (void *)WFPlayer)
		{
			Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
			Device->SetTexture(0, cBack);
			Device->SetRenderState(D3DRS_ZENABLE, false);
			Device->DrawIndexedPrimitive(PrimType, BaseVertexIndex, MinVertexIndex, NumVertices, startIndex, primCount);
			Device->SetTexture(0, cFront);
			Device->SetRenderState(D3DRS_ZENABLE, true);
			Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
			Device->DrawIndexedPrimitive(PrimType, BaseVertexIndex, MinVertexIndex, NumVertices, startIndex, primCount);
			Device->SetTexture(0, cFront);
			Device->SetRenderState(D3DRS_ALPHABLENDENABLE, false);
		}
 
	if (WallHack)
		if (ReturnAddress == (void *)WFPlayer)
	{
		Device->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
		Device->SetRenderState(D3DRS_ZENABLE, false);
		Device->DrawIndexedPrimitive(PrimType, BaseVertexIndex, MinVertexIndex, NumVertices, startIndex, primCount);
		Device->SetRenderState(D3DRS_ZENABLE, true);
		Device->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	}
 
 
	if (Trippin && ReturnAddress != NULL && ReturnAddress == (void *)0xA4CBB7) {
		Device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCCOLOR);
		Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
	}
 
	if (Wireframe)
		if (ReturnAddress == (void *)WFPlayer)
	{
		Device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
	}
	else {
		Device->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	}
 
	if (NoSmoke && ReturnAddress != NULL && ReturnAddress == (void *)WarfaceSmoke)
	{
		return D3D_OK;
	}
 
	if (Esp)
		if (Stride == 16 && pSizeOfData == 640)
	{
		AddModel(Device, 1);
	}
 
	return xDrawIndexedPrimitive(Device, PrimType, BaseVertexIndex, MinVertexIndex, NumVertices, startIndex, primCount);
}
 
 
void cDirectClass::InitObjects(IDirect3DDevice9 * Device)
{
 
}
 
void cDirectClass::DrawLine(float StartX, float StartY, float EndX, float EndY, D3DCOLOR dColor)
{
	XLine->SetWidth(1);
	XLine->SetGLLines(0);
	XLine->SetAntialias(1);
 
	D3DXVECTOR2 v2Line[2];
	v2Line[0].x = StartX;
	v2Line[0].y = StartY;
	v2Line[1].x = EndX;
	v2Line[1].y = EndY;
 
	XLine->Begin();
	XLine->Draw(v2Line, 2, dColor);
	XLine->End();
}
 
cDirectClass cDirectX;
 
void Button(IDirect3DDevice9* dev, int x, int y, int w, int h, D3DCOLOR Outline)
{
	DrawRect(dev, x, y, w, 1, Outline);
	DrawRect(dev, x, y, 1, h, Outline);
	DrawRect(dev, x + w, y, 1, h, Outline);
	DrawRect(dev, x, y + h, w, 1, Outline);
}
 
void AddInt(int Pos, const char *text, int controller)
{
	DWORD OnColor = d3dColorGreen;
	DWORD OffColor = d3dColorWhite;
	if (controller)
	{
		cDirectX.DrawString(XFont, Menux + ItemOffset, (Menuy) + ((Pos - 1) * 15), OnColor, text);
		cDirectX.DrawString(XFont, Menux + ValueOffset, (Menuy) + ((Pos - 1) * 15), OnColor, "%i.00", controller);
	}
	else if (!controller)
	{
		cDirectX.DrawString(XFont, Menux + ItemOffset, (Menuy) + ((Pos - 1) * 15), OffColor, text);
		cDirectX.DrawString(XFont, Menux + ValueOffset, (Menuy) + ((Pos - 1) * 15), OffColor, "0.00");
	}
}
 
void AddBool(int Pos, const char *text, bool controller)
{
	DWORD OnColor = d3dColorGreen;
	DWORD OffColor = d3dColorWhite;
	if (controller)
	{
		cDirectX.DrawString(XFont, Menux + ItemOffset, (Menuy) + ((Pos - 1) * 15), OnColor, text);
		cDirectX.DrawString(XFont, Menux + ValueOffset, (Menuy) + ((Pos - 1) * 15), OnColor, "On");
	}
	else if (!controller)
	{
		cDirectX.DrawString(XFont, Menux + ItemOffset, (Menuy) + ((Pos - 1) * 15), OffColor, text);
		cDirectX.DrawString(XFont, Menux + ValueOffset, (Menuy) + ((Pos - 1) * 15), OffColor, "Off");
	}
}
void bAddInt(int Pos, const char *text, int controller)
{
	DWORD OnColor = d3dColorGreen;
	DWORD OffColor = d3dColorWhite;
	if (controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, "%i.00", controller);
	}
	else if (!controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, "0.00");
	}
}
 
void bAddBool(int Pos, const char *text, bool controller)
{
	DWORD OnColor = d3dColorGreen;
	DWORD OffColor = d3dColorWhite;
	if (controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, "On");
	}
	else if (!controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, "Off");
	}
}
 
void cAddInt(int Pos, const char *text, int controller)
{
	DWORD OnColor = d3dColorGreen;
	DWORD OffColor = d3dColorWhite;
	if (controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, "%i.00", controller);
	}
	else if (!controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, "0.00");
	}
}
 
void cAddBool(int Pos, const char *text, bool controller)
{
	DWORD OnColor = d3dColorGreen;
	DWORD OffColor = d3dColorWhite;
	if (controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OnColor, "On");
	}
	else if (!controller)
	{
		cDirectX.DrawString(XFont, bMenux + ItemOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, text);
		cDirectX.DrawString(XFont, bMenux + ValueOffsetB, (bMenuy)+((Pos - 1) * 15), OffColor, "Off");
	}
}
 
 
int Menu_Max = 12;
void SetIntLimits(int controller, int max, int min)
{
	if (controller == max + 1)
	{
		controller = max;
	}
	if (controller == min - 1)
	{
		controller = min;
	}
}
 
void SetIntLoop(int controller, int max, int min)
{
	if (controller == max + 1)
	{
		controller = min;
	}
	if (controller == min - 1)
	{
		controller = max;
	}
}
 
void AddIntItem(int Pos, const char *test, int controller, int max, int min) {
	AddInt(Pos, test, controller);
	SetIntLimits(controller, max, min);
}
 
void CaseFunction()
{
	if (!EspSettings)
		if (!AimSettings)
		if (Menu && ((GetAsyncKeyState(VK_UP) & 1)))
		{
			if (aMenuSelection > 0)
				aMenuSelection--;
		}
 
	if (!EspSettings)
		if (!AimSettings)
		if (Menu && ((GetAsyncKeyState(VK_DOWN) & 1)))
		{
			if (aMenuSelection < Menu_Max)
				aMenuSelection++;
		}
 
	if (!EspSettings)
		if (!AimSettings)
		if (Menu && ((GetAsyncKeyState(VK_RIGHT) & 1)))
		{
			{
				switch (aMenuSelection)
				{
				case 0:
					Chams = !Chams;
					break;
				case 1:
					Glow = !Glow;
					break;
				case 2:
					Frontcolor = !Frontcolor && !Backcolor;
					break;
				case 3:
					Backcolor = !Backcolor && !Frontcolor;
					break;
				case 4:
					Aimbot = !Aimbot;
					break;
				case 5:
					Esp = !Esp;
					break;
				case 6:
					NoSmoke = !NoSmoke;
					break;
				case 7:
					EspSettings = !EspSettings;
					break;
				case 8:
					AimSettings = !AimSettings;
					break;
				case 9:
					Wireframe = !Wireframe;
					break;
				case 10:
					Crosshair++;
					if (Crosshair > 7)
						Crosshair--;
					break;
				case 11:
					WallHack = !WallHack;
					break;
				case 12:
					LTrippin = !LTrippin;
					break;
				}
			}
		}
 
	if (!EspSettings)
		if (!AimSettings)
		if (Menu && ((GetAsyncKeyState(VK_LEFT) & 1)))
		{
			if (Menu)
			{
				switch (aMenuSelection)
				{
				case 0:
					Chams = !Chams;
					break;
				case 1:
					Glow = !Glow;
					break;
				case 2:
					Frontcolor = !Frontcolor && !Backcolor;
					break;
				case 3:
					Backcolor = !Backcolor && !Frontcolor;
					break;
				case 4:
					Aimbot = !Aimbot;
					break;
				case 5:
					Esp = !Esp;
					break;
				case 6:
					NoSmoke = !NoSmoke;
					break;
				case 7:
					EspSettings = !EspSettings;
					break;
				case 8:
					AimSettings = !AimSettings;
					break;
				case 9:
						Wireframe = !Wireframe;
				break;
				case 10:
						Crosshair--;
						if (Crosshair < 0)
							Crosshair++;
				break;
					case 11:
						WallHack = !WallHack;
						break;
					case 12:
						LTrippin = !LTrippin;
						break;
				}
			}
		}
}
 
	void bSetIntLimits(int bcontroller, int bmax, int bmin)
	{
		if (bcontroller == bmax + 1)
		{
			bcontroller = bmax;
		}
		if (bcontroller == bmin - 1)
		{
			bcontroller = bmin;
		}
	}
 
	void bSetIntLoop(int bcontroller, int bmax, int bmin)
	{
		if (bcontroller == bmax + 1)
		{
			bcontroller = bmin;
		}
		if (bcontroller == bmin - 1)
		{
			bcontroller = bmax;
		}
	}
 
	int bMenu_Max = 11;
 
	void bAddIntItem(int bPos, const char *test, int bcontroller, int bmax, int bmin) {
		bAddInt(bPos, test, bcontroller);
		bSetIntLimits(bcontroller, bmax, bmin);
	}
 
	void bCaseFunction()
	{
		if (!AimSettings)
		if (EspSettings && ((GetAsyncKeyState(VK_UP) & 1)))
		{
			if (bMenuSelection > 0)
				bMenuSelection--;
		}
 
		if (!AimSettings)
		if (EspSettings && ((GetAsyncKeyState(VK_DOWN) & 1)))
		{
			if (bMenuSelection < bMenu_Max)
				bMenuSelection++;
		}
 
		if (!AimSettings)
		if (EspSettings && ((GetAsyncKeyState(VK_RIGHT) & 1)))
		{
			if (EspSettings)
			{
				switch (bMenuSelection)
				{
				case 0:
					Boxes = !Boxes;
					break;
				case 1:
					Espr += 10;
					if (Espr > 255)
						Espr-=10;
					break;
				case 2:
					Espg += 10;
					if (Espg > 255)
						Espg -= 10;
					break;
				case 3:
					Espb += 10;
					if (Espb > 255)
						Espb -= 10;
					break;
				case 4:
					AimEsp = !AimEsp;
					break;
				case 5:
					dCounter = !dCounter;
					break;
				case 6:
					BoneDot = !BoneDot;
					break;
				case 7:
					BoneCircle = !BoneCircle;
					break;
				case 8:
					BoneCrosshair = !BoneCrosshair;
					break;
				case 9:
					Lines = !Lines;
					break;
				case 10:
					AimHeight += 0.1;
					if (AimHeight > 2)
						AimHeight -= .1;
					break;
				case 11:
					EspSettings = !EspSettings;
					break;
				}
			}
		}
 
		if (!AimSettings)
		if (EspSettings && ((GetAsyncKeyState(VK_LEFT) & 1)))
		{
			if (EspSettings)
			{
				switch (bMenuSelection)
				{
				case 0:
					Boxes = !Boxes;
					break;
				case 1:
					Espr--;
					if (Espr < 0)
						Espr += 1;
					break;
				case 2:
					Espg--;
					if (Espg < 0)
						Espg += 1;
					break;
				case 3:
					Espb--;
					if (Espb < 0)
						Espb+=1;
					break;
				case 4:
					AimEsp = !AimEsp;
					break;
				case 5:
					dCounter = !dCounter;
					break;
				case 6:
					BoneDot = !BoneDot;
					break;
				case 7:
					BoneCircle = !BoneCircle;
					break;
				case 8:
					BoneCrosshair = !BoneCrosshair;
					break;
				case 9:
					Lines = !Lines;
					break;
				case 10:
					AimHeight -= 0.1;
					if (AimHeight < 0)
						AimHeight += .1;
					break;
				case 11:
					EspSettings = !EspSettings;
					break;
				}
			}
		}
	}
 
	void cSetIntLimits(int ccontroller, int cmax, int cmin)
	{
		if (ccontroller == cmax + 1)
		{
			ccontroller = cmax;
		}
		if (ccontroller == cmin - 1)
		{
			ccontroller = cmin;
		}
	}
 
	void cSetIntLoop(int ccontroller, int cmax, int cmin)
	{
		if (ccontroller == cmax + 1)
		{
			ccontroller = cmin;
		}
		if (ccontroller == cmin - 1)
		{
			ccontroller = cmax;
		}
	}
 
	int cMenu_Max = 3;
 
	void cAddIntItem(int cPos, const char *test, int ccontroller, int cmax, int cmin) {
		cAddInt(cPos, test, ccontroller);
		cSetIntLimits(ccontroller, cmax, cmin);
	}
 
	void cCaseFunction()
	{
		if(!EspSettings)
		if (AimSettings && ((GetAsyncKeyState(VK_UP) & 1)))
		{
			if (cMenuSelection > 0)
				cMenuSelection--;
		}
		if (!EspSettings)
		if (AimSettings && ((GetAsyncKeyState(VK_DOWN) & 1)))
		{
			if (cMenuSelection < cMenu_Max)
				cMenuSelection++;
		}
		if (!EspSettings)
		if (AimSettings && ((GetAsyncKeyState(VK_RIGHT) & 1)))
		{
			if (AimSettings)
			{
				switch (cMenuSelection)
				{
				case 0:
					AimSens += 0.5 ;
					if (AimSens > 5)
						AimSens -= .5;
					break;
				case 1:
					AimHeight += 0.1;
					if (AimHeight > 2)
						AimHeight -= .1;
					break;
				case 2:
					AimKey += 1;
					if (AimKey > 8)
						AimKey -= 1;
					break;
				case 3:
					AimSettings = !AimSettings;
					break;
				}
			}
		}
 
		if (!EspSettings)
		if (AimSettings && ((GetAsyncKeyState(VK_LEFT) & 1)))
		{
			if (AimSettings)
			{
				switch (cMenuSelection)
				{
				case 0:
					AimSens--;
					if (AimSens < 0)
						AimSens++;
					break;
				case 1:
					AimHeight -= 0.1;
					if (AimHeight < 0)
						AimHeight += .1;
					break;
				case 2:
					AimKey -= 1;
					if (AimKey < 0)
						AimKey += 1;
					break;
				case 3:
					AimSettings = !AimSettings;
					break;
				}
			}
		}
	}
